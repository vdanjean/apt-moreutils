#!/usr/bin/python
"""Check the origin of all packages"""

import getopt,sys
import apt_pkg
import os
import re
import types
import xdg.BaseDirectory
import shutil
progusage="apt-origins [options]"
shortoptions=["h","l","c","m","t","C:","L:","o:"]
longoptions=["help", "list","count","manual","tabular","columns=","lines=","order=","help-nroff"]
argstype=['','','','','','integer','integer','string']
explanation=['This help text',
             'Just list available distributions',
             'Just display package count by origin',
             'Only display manually installed packages',
             'Use tabular output format for origin display',
             'Set the number of columns of the output',
             'Set the maximal number of packages that can be displayed',
             'Set the order in which packages are in the distributions.\n    This is a space-jointed string of stanzas like\n    alias1~site1/archive1/o=origin1/l=label1/a=arch1 where alias1 is the display name of\n    a distribution of name archive1 at site1, label1 and origin1 being the\n    values in the Release file. "none" will purge the preceding sources. Giving\n    only the alias will reselect the defined alias if none was given.\n    Regexp stanza for package names can be used instead of a mirror.\n    Simply use REName:pkgname.*$ for any package named beginning by pkgname).'
             ]

loglevel=2

def log(s, level=1):
    if level <= loglevel:
        print s

def debug(s, level=2):
    log("D: "+s, level)

def usage():
    """Usage for this program."""
    print progusage
    for k in range(len(longoptions)):
        if longoptions[k]=='help-nroff':
            continue
        if k<len(shortoptions):
            x='-'+shortoptions[k][0:1]+'|--'+longoptions[k]
            x=x+argstype[k]
        else:
            x='--'+longoptions[k]+argstype[k]
        print "  %-20s %s" % (x,explanation[k])

def usagenroff():
    """Usage for this program in NROFF format."""
    print progusage
    print ".SH OPTIONS"
    for k in range(len(longoptions)):
        if longoptions[k]=='help-nroff':
            continue
        if k<len(shortoptions):
            x='\\fB-'+shortoptions[k][0:1]+'\\fR|\\fB--'+longoptions[k]+'\\fR'
        else:
            x='\\fB--'+longoptions[k]+'\\fR'
        if len(argstype[k])>0:
            x=x+" \\fI"+argstype[k]+"\\fR"
        print ".TP"
        print x
        print explanation[k]

def fix_config_file_location():
    base_path=xdg.BaseDirectory.load_first_config('apt-origins')
    if base_path == None:
        try:
            home=os.getenv('HOME',default='.')
            orig=os.path.join(home, '.apt-origins')
            if not os.path.isfile(orig):
                return
            savedir=xdg.BaseDirectory.save_config_path('apt-origins')
            new=os.path.join(savedir, 'stanzas.list')
            log("Old configuration file detected without new one. Moving the old one to the new location")
            log("Old configuration file location: %s" % orig)
            log("New configuration file location: %s" % new)
            shutil.move(orig, new)
        except IOError:
            True

class Sources:
    PKG_UNKNOWN    = -1
    PKG_UPGRADABLE = -2
    PKG_DOWNGRADABLE    = -3

    def __init__(self):
        # Array of sources/names
        self.sources=[]
        self.names=[]
        
        self.originalpattern={}
        self.nb_sources=0
        self.spatterns={}
        self.count={}
        self.packages={}
        self.REsrcs=[]

    def register(self, v):
        xx=v.find('~')
        if xx!=-1:
            a=v[0:xx]
            c=v[xx+1:]
        else:
            c=v
            a=v
        if c in self.spatterns:
            debug("Skipping %s~%s (pattern already registered)" % (a, c))
            return
        idsrc=self.nb_sources
        debug("register sources[%i]=%s, names[%i]=%s" % (idsrc, c, idsrc, a), level=3)
        self.spatterns[c]=idsrc
        xx=c.find('REName:')
        if xx==0:
            originalpatternstring=c
            c=re.compile(c[xx+7:])
            self.originalpattern[idsrc]=originalpatternstring
            self.REsrcs.append(idsrc)
        self.sources.append(c)
        self.names.append(a)
        self.nb_sources += 1
        return idsrc

    def registerInstalled(self):
        for (sid,name) in [
            (Sources.PKG_UPGRADABLE, "installed/upgradable"),
            (Sources.PKG_DOWNGRADABLE, 'installed/downgradable'),
            (Sources.PKG_UNKNOWN, 'installed/unknown') ]:
            if len(self.pkgs(sid)) > 0:
                self.names.append(name)
                idsrc=self.nb_sources
                self.nb_sources += 1
                self.packages[idsrc]=self.packages[sid]

    def __len__(self):
        return self.nb_sources

    def name(self, idsrc):
        return self.names[idsrc]

    def pattern(self, idsrc):
        s=self.sources[idsrc]
        if type(s)==types.StringType:
            return s
        return self.originalpattern[idsrc]

    def get(self, src):
        return self.spatterns.get(src, None)

    def minREid(self):
        if len(self.REsrcs) == 0:
            return None
        return min(self.REsrcs)

    def getRE(self, name):
        for idsrc in self.REsrcs:
            if self.sources[idsrc].match(name):
                return idsrc
        return None

    def addPkg(self, idsrc, name, archname):
        if not (idsrc in self.packages):
            self.packages[idsrc]={}
        if not (name in self.packages[idsrc]):
            self.packages[idsrc][name]={ 'list': [archname] }
        else:
            self.packages[idsrc][name]['list'].append(archname)
        if name == archname:
            self.packages[idsrc][name]['native']=name

    def pkgs(self, idsrc):
        return self.packages.get(idsrc, {})

    def pkgname(self, pkg):
        name=pkg.get('native', pkg['list'][0])
        nb=len(pkg['list'])
        if nb > 1:
            name=("%s(%i)" % (name, nb))
        return name

    def pkgnames(self, idsrc):
        return [ self.pkgname(pkg) for pkg in self.pkgs(idsrc).values() ]
          
        

def main():
    """The main function"""
    try:
        opts, args = getopt.getopt(sys.argv[1:], "".join(shortoptions),
                                   longoptions)
    except getopt.GetoptError:
        usage()
        sys.exit(1)
    justlist=False
    justcount=False
    onlymanual=False
    optiontabular=False
    defsources={}
    xsources=[]
    xlimit=100
    cols=80
    environfile=False
    fix_config_file_location()
    for dirname in xdg.BaseDirectory.load_config_paths('apt-origins'):
        try:
             filename=os.path.join(dirname, 'stanzas.list')
             #print("Reading config from %s" % filename)
             f=open(filename,'r')
             environfile=True
             for line in f:
                if len(line)>1 and line[0] != '#':
                    s=line.rstrip('\n')
                    x=s.find('~')
                    if x!=-1:
                        xsources.append(s)
                        try:
                            defsources[s[0:x]].append(s)
                        except KeyError:
                            defsources[s[0:x]]=[s]
             f.close()
        except IOError:
            True
    for o,a in opts:
        if o in ("-h","--help"):
            usage()
            sys.exit()
        elif o in ("--help-nroff"):
            usagenroff()
            sys.exit()
        elif o in ("-l","--list"):
            justlist=True
        elif o in ("-c","--count"):
            justcount=True
        elif o in ("-t","--total"):
            optiontabular=True
        elif o in ("-m","--manual"):
            onlymanual=True
        elif o in ("-L","--lines"):
            xlimit=int(a)
        elif o in ("-C","--columns"):
            cols=int(a)
        elif o in ("-o","--order"):
            if (a=='none'):
                xsources=[]
            else:
                x=a.find('~')
                if x==-1 and defsources[a]:
                    xsources += defsources[a]
                else:
                    xsources.append(a)
        else:
            assert False, "unhandled option"
    apt_pkg.init_config()
    apt_pkg.init_system()
    cache=None
    if loglevel < 1:
        cache=apt_pkg.Cache(None)
    else:
        cache=apt_pkg.Cache()
    depcache=apt_pkg.DepCache(cache)
    apt_pkg.init()
    srcs = Sources()
    for v in xsources:
        srcs.register(v)
    minREsrc=srcs.minREid()
    heuristic=re.compile(r"(.(org|net|com)$)|(^www.)|(^ftp.[a-z]{2,3}.)|(^ftp.)")
    for pkg in cache.packages:
        version=pkg.current_ver
        if version != None and pkg.current_state == apt_pkg.CURSTATE_INSTALLED and (not(onlymanual) or not(depcache.is_auto_installed(pkg))):
            idsource=len(srcs)+1
            file_list=version.file_list
            for pfile,_ in file_list:
                if pfile.index_type == "Debian Package Index":
                    cpt=pfile.site+'/'+pfile.archive+'/o='+pfile.origin+'/l='+pfile.label+'/a='+pfile.architecture
                    idsrc=srcs.get(cpt)
                    if idsrc is not None:
                        idsource=min(idsource, idsrc)
            if minREsrc is not None and idsource > minREsrc:
                # perhaps a regexp would work (if some exist with better priority than currently)
                idsrc=srcs.getRE(pkg.name)
                if idsrc is not None:
                    idsource=min(idsource, idsrc)
            if idsource < len(srcs):
                srcs.addPkg(idsource, pkg.name, pkg.get_fullname(True))
                continue

            # no source found
            for pfile,_ in file_list:
                if pfile.index_type == "Debian Package Index":
                    # we register the first found if there are any
                    cpt=pfile.site+'/'+pfile.archive+'/o='+pfile.origin+'/l='+pfile.label+'/a='+pfile.architecture
                    alias_heuristic=re.sub(heuristic,'',pfile.site)+'.'+pfile.archive;
                    name=alias_heuristic+":"+pfile.site
                    idsource=srcs.register(name+'~'+cpt)
                    srcs.addPkg(idsource, pkg.name, pkg.get_fullname(True))
                    break
            else:
                # else the package will go in one installed list
                dversion = [ v for v in pkg.version_list if v.downloadable ]
                ver_str = version.ver_str
                if len(dversion) == 0:
                    srcs.addPkg(Sources.PKG_UNKNOWN, pkg.name, pkg.get_fullname(True))
                elif next(( v for v in dversion if apt_pkg.version_compare(ver_str, v.ver_str) < 0), None) is not None:
                    srcs.addPkg(Sources.PKG_UPGRADABLE, pkg.name, pkg.get_fullname(True))
                else:
                    srcs.addPkg(Sources.PKG_DOWNGRADABLE, pkg.name, pkg.get_fullname(True))
    if justlist:
        #print "#other and installed are always added by this program"
        print "#installed/(upgradable|downgradable|unknown) are always added by this program"
        print "#Check that aliases are meaningful enough"
        #print "#other: downloadable packages from unnamed repositories"
        print "#installed: packages installed but not downloadable"
        print "#  /upgradable: new versions are downloadable"
        print "#  /downgradable: older versions are downloadable (pkg removed from the archive?)"
        print "#  /unknown: no versions to download (installed with 'dpkg -i'?)"
        for i in range(len(srcs)):
            n=srcs.name(i)
            s=srcs.pattern(i)
            if len(srcs.pkgs(i)) == 0:
                print "# no currently matching packages for "+n
            print n+'~'+s
        sys.exit()
    srcs.registerInstalled()
    if justcount:
        for i in range(len(srcs)):
            nb=len(srcs.pkgs(i))
            if (nb > 0):
                print '%s:%d' % (srcs.name(i), nb)
        sys.exit()
    elif optiontabular:
        for i in range(len(srcs)):
            name=srcs.name(i)
            for u in sorted(srcs.pkgnames(i)):
                print name+':'+u
    else:
        prevname=None
        disp_packages=[]
        for i in range(len(srcs)):
            name=srcs.name(i)
            if len(srcs.pkgs(i))==0:
                continue
            # if two consecutive sections have the same name, we merge them
            if prevname != name:
                    display_package_list(disp_packages, cols, xlimit)
                    print ','+("-" * (cols-2))+'.'
                    print '|'+name.center(cols-2)+'|'
                    print '`'+("-" * (cols-2))+'\''
                    prevname=name
                    disp_packages=[]
            disp_packages += srcs.pkgnames(i)
        display_package_list(disp_packages, cols, xlimit)

def display_package_list(packages, cols, xlimit):
    new=''
    packages=sorted(set(packages))
    if len(packages)>xlimit:
        print 'Too many packages (%d). Use --tabular or --lines=X (x>=%d).' % (len(packages),len(packages))
    else:
        for u in sorted(packages):
            if len(new)+len(u)+1<=cols:
                if new!='':
                    new=new+' '+u
                else:
                    new=u
            else:
                print new
                new=u
        if len(new)>0:
            print new

if __name__ == '__main__':
    main() 
    
